# -*- coding: utf-8 -*-
"""AlphaEngine.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zvrr4NPS7a3ZeTaTa19x6ErsZ4SSuxAt
"""



""""This strategy seems cool! If I used this exact same strategy three months ago, how much would I have gained or lost?"

Unfortunately, we do not have a time machine, but we have something that's pretty close from a financial maths perspective - the backtesting engine.
"""

!pip install yfinance matplotlib

"""I) We will now install four libraries essential for the backtesting engine:"""

import yfinance as yf # allows us to download stock price data
import matplotlib.pyplot as plt # allows us to create charts and graphs
import pandas as pd # acts as an analysis tool for time series and data frames
import numpy as np # provides us with mathematical objects, such as matrices

"""II) Load the historical data into the data frame **ae**. We wish to view the history of Apple's stocks, so we need to find the corresponding stock ticker for Apple - represented as **AAPL** by Yahoo Finance."""

ticker = 'AAPL'
ae = yf.download(ticker, start="2020-06-05", end="2025-06-05")
ae = ae[['Close']] # we only care about the closing prices

"""III) Note: we are using the moving average crossover strategy, so we must create two SMA functions - the fast function with a 20-day lookback window and the slow function with a 50-day lookback window."""

ae['SM_fast'] = ae['Close'].rolling(window=20).mean()
ae['SM_slow'] = ae['Close'].rolling(window=50).mean()

"""IV) Use **pandas** to create a neutral column, **signal**, in the dataframe **ae**, containing zeroes. For every row where *SM_fast* is greater than *SM_slow*, replace the 0 with a 1. For every row where *SM_fast* is slower than *SM_slow*, replace the 0 with a -1."""

ae['signal'] = 0
ae.loc[ae['SM_fast'] > ae['SM_slow'], 'signal'] = 1 # buy signal
ae.loc[ae['SM_fast'] < ae['SM_slow'], 'signal'] = -1 # sell signal

"""V) Create another column, **position**, which represents the trading position on a given day."""

ae['position'] = ae['signal'].shift(1) # position taken on day t is based on signal generated on day t-1
ae.dropna(inplace=True) # removes invalid entries in ae

"""VI) Compute the daily return of the asset using the percentage change in closing prices on two consecutive days."""

ae['market_return'] = ae['Close'].pct_change()
ae['strategy_return'] = ae['position'] * ae['market_return']

"""VII) Let us now evaluate the performance of this engine. Pick a generic transaction cost (e.g, 0.1)."""

transaction_cost = 0.001 # simulates real-life trading where fees are involved

"""VIII) Refer to 1.1 and 1.2 in the Trading Strategy Back Testing Report."""

ae['trade'] = ae['position'].diff().abs()
ae['net_strategy_return'] = ae['strategy_return'] - ae['trade'] * transaction_cost

"""IX) Find the cumulative performance of this trading strategy using the cumulative net strategy return (CNSR)."""

ae['cumulative_market_return'] = (1 + ae['market_return']).cumprod() - 1
# finds cumulative return and denotes the amount you would have if you bought assets on day 1 and held
ae['cumulative_net_strategy_return'] = (1 + ae['net_strategy_return']).cumprod() - 1
# denotes the real-world cumulative performance of this strategy

"""X) Find the cumulative performance of this trading strategy using the Sharpe Ratio."""

sharpe_ratio = (ae['net_strategy_return'].mean() / ae['net_strategy_return'].std()) * np.sqrt(252)

"""XI) Find the cumulative performance of this trading strategy using drawdown."""

rolling_max = ae['cumulative_net_strategy_return'].cummax() # returns highest value of the CNSR at time t
drawdown = ae['cumulative_net_strategy_return'] - rolling_max # returns how far the strategy is from its max at time t
max_drawdown = drawdown.min() # returns the worst drawdown

"""XII) Compute the results."""

print(f"Sharpe Ratio: {sharpe_ratio:.2f}")
print(f"Max Drawdown: {max_drawdown:.2%}")